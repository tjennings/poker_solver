import pytest
from core.exploitability import best_response_value, compute_exploitability
from games.kuhn import KuhnPoker


class TestBestResponse:
    @pytest.fixture
    def game(self):
        return KuhnPoker()

    def test_best_response_against_always_fold(self, game):
        """Against always-fold, best response should win big."""
        # Opponent always folds (passes) to any bet
        strategy = {
            "0:": {"p": 0.0, "b": 1.0},    # Always bet
            "0:pb": {"p": 1.0, "b": 0.0},  # Always fold
            "1:": {"p": 0.0, "b": 1.0},
            "1:pb": {"p": 1.0, "b": 0.0},
            "2:": {"p": 0.0, "b": 1.0},
            "2:pb": {"p": 1.0, "b": 0.0},
            "0:p": {"p": 1.0, "b": 0.0},   # Always fold
            "0:b": {"p": 1.0, "b": 0.0},
            "1:p": {"p": 1.0, "b": 0.0},
            "1:b": {"p": 1.0, "b": 0.0},
            "2:p": {"p": 1.0, "b": 0.0},
            "2:b": {"p": 1.0, "b": 0.0},
        }

        # Best response should achieve positive value
        br_value = best_response_value(game, strategy, exploiting_player=0)
        assert br_value > 0

    def test_exploitability_of_uniform_strategy(self, game):
        """Uniform random strategy should be highly exploitable."""
        strategy = {
            info_set: {"p": 0.5, "b": 0.5}
            for info_set in [
                "0:", "1:", "2:", "0:pb", "1:pb", "2:pb",
                "0:p", "1:p", "2:p", "0:b", "1:b", "2:b"
            ]
        }

        exploit = compute_exploitability(game, strategy)
        assert exploit > 0.05  # Should be quite exploitable


class TestExploitability:
    def test_exploitability_decreases_with_training(self):
        """More CFR iterations should reduce exploitability."""
        from cfr.vanilla import VanillaCFR

        game = KuhnPoker()

        # Use separate instances to avoid average strategy accumulation effects
        cfr_100 = VanillaCFR(game)
        cfr_100.train(iterations=100)
        exploit_100 = compute_exploitability(game, cfr_100.get_all_average_strategies())

        cfr_5000 = VanillaCFR(game)
        cfr_5000.train(iterations=5000)
        exploit_5000 = compute_exploitability(game, cfr_5000.get_all_average_strategies())

        # With more iterations, exploitability should decrease
        assert exploit_5000 < exploit_100
        # Should be substantially lower with 50x more iterations
        assert exploit_5000 < 0.02
